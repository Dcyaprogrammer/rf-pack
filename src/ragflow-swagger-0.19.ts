/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Ragflow HTTP API
 * OpenAPI 3.1.0 specification: dataset, document, agent and RAG conversation flow management.

 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface RaptorConfig {
  use_raptor?: boolean;
}

export interface GraphragConfig {
  use_graphrag?: boolean;
}

/**
 * Parser configuration for the 'naive' chunk method at the dataset level.
 */
export interface ParserConfigNaive {
  /**
   * @minimum 0
   * @maximum 32
   */
  auto_keywords?: number;
  /**
   * @minimum 0
   * @maximum 10
   */
  auto_questions?: number;
  /**
   * @minimum 1
   * @maximum 2048
   */
  chunk_token_num?: number;
  delimiter?: string;
  /** Indicates whether to convert Excel documents into HTML format. */
  html4excel?: boolean;
  layout_recognize?: string;
  /** A list of dataset IDs parsed using the Tag Chunk Method. */
  tag_kb_ids?: string[];
  /**
   * For PDF only.
   * @minimum 1
   */
  task_page_size?: number;
  raptor?: RaptorConfig;
  graphrag?: GraphragConfig;
}

/**
 * Parser configuration for methods like 'qa', 'paper', 'book', etc.
 */
export interface ParserConfigWithRaptor {
  raptor?: RaptorConfig;
}

/**
 * An empty parser configuration for methods like 'table', 'picture', etc.
 */
export interface ParserConfigEmpty { [key: string]: unknown }

/**
 * The configuration for the parser at the dataset level. The structure of this object depends on the 'chunk_method' selected.
 */
export type ParserConfig = ParserConfigNaive | ParserConfigWithRaptor | ParserConfigEmpty;

/**
 * Parser configuration for a document with the 'naive' chunk method.
 */
export interface DocumentParserConfigNaive {
  chunk_token_count?: number;
  layout_recognize?: boolean;
  /** Indicates whether to convert Excel documents into HTML format. */
  html4excel?: boolean;
  delimiter?: string;
  /** For PDF only. */
  task_page_size?: number;
  raptor?: RaptorConfig;
}

/**
 * The configuration for the parser at the document level. The structure of this object depends on the 'chunk_method' selected.
 */
export type DocumentParserConfig = DocumentParserConfigNaive | ParserConfigWithRaptor | ParserConfigEmpty;

/**
 * Access permission for the dataset.
 */
export type CreateDatasetRequestPermission = typeof CreateDatasetRequestPermission[keyof typeof CreateDatasetRequestPermission];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateDatasetRequestPermission = {
  me: 'me',
  team: 'team',
} as const;

/**
 * The chunking method to use for the dataset.
 */
export type CreateDatasetRequestChunkMethod = typeof CreateDatasetRequestChunkMethod[keyof typeof CreateDatasetRequestChunkMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateDatasetRequestChunkMethod = {
  naive: 'naive',
  book: 'book',
  email: 'email',
  laws: 'laws',
  manual: 'manual',
  one: 'one',
  paper: 'paper',
  picture: 'picture',
  presentation: 'presentation',
  qa: 'qa',
  table: 'table',
  tag: 'tag',
} as const;

export interface CreateDatasetRequest {
  /**
   * Unique name for the dataset. Case-insensitive.
   * @maxLength 128
   */
  name: string;
  /**
   * Base64 encoded avatar image.
   * @maxLength 65535
   */
  avatar?: string;
  /**
   * A brief description of the dataset.
   * @maxLength 65535
   */
  description?: string;
  /**
   * Embedding model in 'model_name@model_factory' format.
   * @maxLength 255
   */
  embedding_model?: string;
  /** Access permission for the dataset. */
  permission?: CreateDatasetRequestPermission;
  /** The chunking method to use for the dataset. */
  chunk_method?: CreateDatasetRequestChunkMethod;
  parser_config?: ParserConfig;
}

/**
 * Updated access permission for the dataset.
 */
export type UpdateDatasetRequestPermission = typeof UpdateDatasetRequestPermission[keyof typeof UpdateDatasetRequestPermission];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateDatasetRequestPermission = {
  me: 'me',
  team: 'team',
} as const;

/**
 * Updated chunking method for the dataset.
 */
export type UpdateDatasetRequestChunkMethod = typeof UpdateDatasetRequestChunkMethod[keyof typeof UpdateDatasetRequestChunkMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateDatasetRequestChunkMethod = {
  naive: 'naive',
  book: 'book',
  email: 'email',
  laws: 'laws',
  manual: 'manual',
  one: 'one',
  paper: 'paper',
  picture: 'picture',
  presentation: 'presentation',
  qa: 'qa',
  table: 'table',
  tag: 'tag',
} as const;

export interface UpdateDatasetRequest {
  /**
   * Revised name for the dataset. Case-insensitive.
   * @maxLength 128
   */
  name?: string;
  /**
   * Updated Base64 encoded avatar image.
   * @maxLength 65535
   */
  avatar?: string;
  /**
   * Updated description of the dataset.
   * @maxLength 65535
   */
  description?: string;
  /**
   * Updated embedding model. Requires 'chunk_count' to be 0 before updating.
   * @maxLength 255
   */
  embedding_model?: string;
  /** Updated access permission for the dataset. */
  permission?: UpdateDatasetRequestPermission;
  /**
   * Page rank setting.
   * @minimum 0
   * @maximum 100
   */
  pagerank?: number;
  /** Updated chunking method for the dataset. */
  chunk_method?: UpdateDatasetRequestChunkMethod;
  parser_config?: ParserConfig;
}

export interface DeleteDatasetsRequest {
  /**
   * An array of dataset IDs to delete. If null, all datasets are deleted.
   * @nullable
   */
  ids: string[] | null;
}

export interface Dataset {
  id?: string;
  name?: string;
  /** @nullable */
  description?: string | null;
  permission?: string;
  /** @nullable */
  avatar?: string | null;
  embedding_model?: string;
  chunk_method?: string;
  parser_config?: ParserConfig;
  status?: string;
  create_date?: string;
  update_date?: string;
  create_time?: number;
  update_time?: number;
  created_by?: string;
  tenant_id?: string;
  document_count?: number;
  chunk_count?: number;
  token_num?: number;
  language?: string;
  pagerank?: number;
  similarity_threshold?: number;
  vector_similarity_weight?: number;
}

export interface CreateDatasetResponse {
  code?: number;
  data?: Dataset;
}

export interface ListDatasetsResponse {
  code?: number;
  data?: Dataset[];
}

export interface UploadDocumentResponseItem {
  id?: string;
  dataset_id?: string;
  location?: string;
  name?: string;
  type?: string;
  size?: number;
  thumbnail?: string;
  run?: string;
  chunk_method?: string;
  parser_config?: ParserConfig;
  created_by?: string;
}

export interface UploadDocumentsResponse {
  code?: number;
  data?: UploadDocumentResponseItem[];
}

/**
 * The meta fields of the document.
 */
export type UpdateDocumentRequestMetaFields = { [key: string]: unknown };

export type UpdateDocumentRequestChunkMethod = typeof UpdateDocumentRequestChunkMethod[keyof typeof UpdateDocumentRequestChunkMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateDocumentRequestChunkMethod = {
  naive: 'naive',
  manual: 'manual',
  qa: 'qa',
  table: 'table',
  paper: 'paper',
  book: 'book',
  laws: 'laws',
  presentation: 'presentation',
  picture: 'picture',
  one: 'one',
  email: 'email',
} as const;

export interface UpdateDocumentRequest {
  name?: string;
  /** The meta fields of the document. */
  meta_fields?: UpdateDocumentRequestMetaFields;
  chunk_method?: UpdateDocumentRequestChunkMethod;
  parser_config?: DocumentParserConfig;
}

export interface Document {
  id?: string;
  knowledgebase_id?: string;
  name?: string;
  location?: string;
  source_type?: string;
  type?: string;
  size?: number;
  /** @nullable */
  thumbnail?: string | null;
  status?: string;
  run?: string;
  progress?: number;
  progress_msg?: string;
  /** @nullable */
  process_begin_at?: string | null;
  process_duation?: number;
  chunk_method?: string;
  parser_config?: DocumentParserConfig;
  chunk_count?: number;
  token_count?: number;
  created_by?: string;
  create_date?: string;
  update_date?: string;
  create_time?: number;
  update_time?: number;
}

export type ListDocumentsResponseData = {
  docs?: Document[];
  total?: number;
};

export interface ListDocumentsResponse {
  code?: number;
  data?: ListDocumentsResponseData;
}

export interface DeleteDocumentsRequest {
  /** The IDs of the documents to delete. If not specified, all documents in the dataset will be deleted. */
  ids?: string[];
}

export interface ManageParsingRequest {
  /** The IDs of the documents to parse or stop parsing. */
  document_ids: string[];
}

export interface AddChunkRequest {
  /** The text content of the chunk. */
  content: string;
  /** The key terms or phrases to tag with the chunk. */
  important_keywords?: string[];
  /** If there is a given question, the embedded chunks will be based on them. */
  questions?: string[];
}

export interface ChunkDetail {
  id?: string;
  document_id?: string;
  dataset_id?: string;
  content?: string;
  important_keywords?: string[];
  questions?: string[];
  create_time?: string;
  create_timestamp?: number;
}

export type AddChunkResponseData = {
  chunk?: ChunkDetail;
};

export interface AddChunkResponse {
  code?: number;
  data?: AddChunkResponseData;
}

export interface Chunk {
  id?: string;
  document_id?: string;
  content?: string;
  available?: boolean;
  docnm_kwd?: string;
  image_id?: string;
  important_keywords?: string;
  positions?: string[];
}

export type ListChunksResponseData = {
  chunks?: Chunk[];
  doc?: Document;
  total?: number;
};

export interface ListChunksResponse {
  code?: number;
  data?: ListChunksResponseData;
}

export interface DeleteChunksRequest {
  /** The IDs of the chunks to delete. If not specified, all chunks of the document will be deleted. */
  chunk_ids?: string[];
}

export interface UpdateChunkRequest {
  /** The text content of the chunk. */
  content?: string;
  /** A list of key terms or phrases to tag with the chunk. */
  important_keywords?: string[];
  /** The chunk's availability status in the dataset. */
  available?: boolean;
}

export interface RetrieveChunksRequest {
  /** The user query or query keywords. */
  question: string;
  /** The IDs of the datasets to search. */
  dataset_ids?: string[];
  /** The IDs of the documents to search. */
  document_ids?: string[];
  /** Specifies the page on which the chunks will be displayed. */
  page?: number;
  /** The maximum number of chunks on each page. */
  page_size?: number;
  /** The minimum similarity score. */
  similarity_threshold?: number;
  /** The weight of vector cosine similarity. */
  vector_similarity_weight?: number;
  /** The number of chunks engaged in vector cosine computation. */
  top_k?: number;
  /** The ID of the rerank model. */
  rerank_id?: string;
  /** Indicates whether to enable keyword-based matching. */
  keyword?: boolean;
  /** Specifies whether to enable highlighting of matched terms in the results. */
  highlight?: boolean;
}

export interface RetrievedChunk {
  id?: string;
  document_id?: string;
  kb_id?: string;
  content?: string;
  content_ltks?: string;
  document_keyword?: string;
  highlight?: string;
  image_id?: string;
  important_keywords?: string[];
  positions?: string[];
  similarity?: number;
  term_similarity?: number;
  vector_similarity?: number;
}

export interface DocAggregation {
  count?: number;
  doc_id?: string;
  doc_name?: string;
}

export type RetrieveChunksResponseData = {
  chunks?: RetrievedChunk[];
  doc_aggs?: DocAggregation[];
  total?: number;
};

export interface RetrieveChunksResponse {
  code?: number;
  data?: RetrieveChunksResponseData;
}

export interface LlmConfig {
  /** The chat model name. If not set, the user's default chat model will be used. */
  model_name?: string;
  /** Controls the randomness of the model's predictions. */
  temperature?: number;
  /** Sets a threshold to select a smaller set of words to sample from. */
  top_p?: number;
  /** Discourages the model from repeating the same information. */
  presence_penalty?: number;
  /** Reduces the model‚Äôs tendency to repeat the same words frequently. */
  frequency_penalty?: number;
}

export interface PromptVariable {
  key?: string;
  optional?: boolean;
}

export interface PromptConfig {
  /** The threshold for similarities between the user query and chunks. */
  similarity_threshold?: number;
  /** The weight of keyword similarity in the hybrid similarity score. */
  keywords_similarity_weight?: number;
  /** The number of top chunks fed to the LLM. */
  top_n?: number;
  /** Variables to use in the 'System' field of Chat Configurations. */
  variables?: PromptVariable[];
  /** If specified, reranking score will be used instead of vector cosine similarity. */
  rerank_model?: string;
  /** The number of items to select for reranking. */
  top_k?: number;
  /** The response to use when no relevant content is found. */
  empty_response?: string;
  /** The opening greeting for the user. */
  opener?: string;
  /** Indicates whether the source of text should be displayed. */
  show_quote?: boolean;
  /** The prompt content. */
  prompt?: string;
}

export interface CreateChatAssistantRequest {
  /** The name of the chat assistant. */
  name: string;
  /** Base64 encoding of the avatar. */
  avatar?: string;
  /** The IDs of the associated datasets. */
  dataset_ids?: string[];
  llm?: LlmConfig;
  prompt?: PromptConfig;
}

export interface UpdateChatAssistantRequest {
  /** The revised name of the chat assistant. */
  name?: string;
  /** Base64 encoding of the avatar. */
  avatar?: string;
  /** The IDs of the associated datasets. */
  dataset_ids?: string[];
  llm?: LlmConfig;
  prompt?: PromptConfig;
}

export interface ChatAssistant {
  id?: string;
  name?: string;
  avatar?: string;
  description?: string;
  language?: string;
  llm?: LlmConfig;
  prompt?: PromptConfig;
  dataset_ids?: string[];
  status?: string;
  do_refer?: string;
  prompt_type?: string;
  tenant_id?: string;
  top_k?: number;
  create_date?: string;
  update_date?: string;
  create_time?: number;
  update_time?: number;
}

export interface ChatAssistantResponse {
  code?: number;
  data?: ChatAssistant;
}

export interface ListChatAssistantsResponse {
  code?: number;
  data?: ChatAssistant[];
}

export interface DeleteChatAssistantsRequest {
  /** The IDs of the chat assistants to delete. If not specified, all assistants will be deleted. */
  ids?: string[];
}

export type ChatMessageRole = typeof ChatMessageRole[keyof typeof ChatMessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChatMessageRole = {
  assistant: 'assistant',
  user: 'user',
} as const;

export interface ChatMessage {
  role?: ChatMessageRole;
  content?: string;
}

export interface Session {
  id?: string;
  name?: string;
  chat_id?: string;
  messages?: ChatMessage[];
  create_date?: string;
  update_date?: string;
  create_time?: number;
  update_time?: number;
}

export interface CreateSessionRequest {
  /** The name of the chat session to create. */
  name?: string;
  /** Optional user-defined ID. */
  user_id?: string;
}

export interface UpdateSessionRequest {
  /** The revised name of the session. */
  name?: string;
  /** Optional user-defined ID. */
  user_id?: string;
}

export interface DeleteSessionsRequest {
  /** The IDs of the sessions to delete. If not specified, all sessions will be deleted. */
  ids?: string[];
}

export interface SessionResponse {
  code?: number;
  data?: Session;
}

export interface ListSessionsResponse {
  code?: number;
  data?: Session[];
}

export interface ConversationRequest {
  /** The question to start an AI-powered conversation. */
  question: string;
  /** Indicates whether to output responses in a streaming way. */
  stream?: boolean;
  /** The ID of session. If not provided, a new session will be generated. */
  session_id?: string;
  /** Optional user-defined ID. Valid only when no session_id is provided. */
  user_id?: string;
}

export interface ConversationReferenceChunk {
  id?: string;
  content?: string;
  document_id?: string;
  document_name?: string;
  dataset_id?: string;
  image_id?: string;
  similarity?: number;
  vector_similarity?: number;
  term_similarity?: number;
  positions?: string[];
}

export interface ConversationReference {
  total?: number;
  chunks?: ConversationReferenceChunk[];
  doc_aggs?: DocAggregation[];
}

export interface ConversationResponseData {
  answer?: string;
  reference?: ConversationReference;
  /** @nullable */
  audio_binary?: string | null;
  /** @nullable */
  id?: string | null;
  session_id?: string;
}

export type ConversationCompletionData = ConversationResponseData | boolean;

export interface ConversationCompletion {
  code?: number;
  data?: ConversationCompletionData;
}

export type ConversationResponseDataProperty = ConversationResponseData | boolean;

export interface ConversationResponse {
  code?: number;
  message?: string;
  data?: ConversationResponseDataProperty;
}

/**
 * The Domain-Specific Language structure defining the agent's graph and components.
 */
export interface AgentSessionDsl { [key: string]: unknown }

export interface AgentSession {
  id?: string;
  agent_id?: string;
  dsl?: AgentSessionDsl;
  message?: ChatMessage[];
  source?: string;
  user_id?: string;
}

export interface CreateAgentSessionResponse {
  code?: number;
  data?: AgentSession;
}

export interface ListAgentSessionsResponse {
  code?: number;
  data?: AgentSession[];
}

/**
 * You can include custom parameters in the request body, but first ensure they are defined in the Begin agent component.
 */
export interface AgentConversationRequest {
  /** The question to start an AI-powered conversation. */
  question: string;
  /** Indicates whether to output responses in a streaming way. */
  stream?: boolean;
  /** The ID of the session. If not provided, a new session will be generated. */
  session_id?: string;
  /** Optional user-defined ID. Valid only when no session_id is provided. */
  user_id?: string;
  /** Whether to synchronize the changes to existing sessions when an agent is modified. */
  sync_dsl?: boolean;
  [key: string]: unknown;
 }

export type AgentConversationResponseDataOneOfReference = { [key: string]: unknown };

export type AgentConversationResponseDataOneOf = {
  answer?: string;
  reference?: AgentConversationResponseDataOneOfReference;
  id?: string;
  session_id?: string;
};

export type AgentConversationResponseData = AgentConversationResponseDataOneOf | boolean;

export interface AgentConversationResponse {
  code?: number;
  message?: string;
  data?: AgentConversationResponseData;
}

export interface RelatedQuestionsRequest {
  /** The original user question. */
  question?: string;
}

export interface RelatedQuestionsResponse {
  code?: number;
  data?: string[];
  message?: string;
}

export interface Agent {
  id?: string;
  title?: string;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  avatar?: string | null;
  dsl?: AgentSessionDsl;
  /** @nullable */
  canvas_type?: string | null;
  user_id?: string;
  create_date?: string;
  update_date?: string;
  create_time?: number;
  update_time?: number;
}

export interface ListAgentsResponse {
  code?: number;
  data?: Agent[];
}

export interface CreateAgentRequest {
  /** The title of the agent. */
  title: string;
  /** The description of the agent. */
  description?: string;
  dsl: AgentSessionDsl;
}

export interface UpdateAgentRequest {
  /** The title of the agent. */
  title?: string;
  /** The description of the agent. */
  description?: string;
  dsl?: AgentSessionDsl;
}

export type OpenAIMessageRole = typeof OpenAIMessageRole[keyof typeof OpenAIMessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIMessageRole = {
  user: 'user',
  assistant: 'assistant',
  system: 'system',
} as const;

export interface OpenAIMessage {
  role?: OpenAIMessageRole;
  content?: string;
}

export interface OpenAIChatCompletionRequest {
  /** The model used to generate the response. The server will parse this automatically. */
  model: string;
  /** A list of historical chat messages. Must contain at least one message with the 'user' role. */
  messages: OpenAIMessage[];
  /** Whether to receive the response as a stream. */
  stream?: boolean;
}

export interface OpenAIUsageDetails {
  accepted_prediction_tokens?: number;
  reasoning_tokens?: number;
  rejected_prediction_tokens?: number;
}

export interface OpenAIUsage {
  prompt_tokens?: number;
  completion_tokens?: number;
  total_tokens?: number;
  completion_tokens_details?: OpenAIUsageDetails;
}

/**
 * @nullable
 */
export type OpenAIChatCompletionChoiceLogprobs = { [key: string]: unknown } | null;

export interface OpenAIChatCompletionChoice {
  finish_reason?: string;
  index?: number;
  /** @nullable */
  logprobs?: OpenAIChatCompletionChoiceLogprobs;
  message?: OpenAIMessage;
}

export interface OpenAIChatCompletionResponse {
  id?: string;
  choices?: OpenAIChatCompletionChoice[];
  /** Unix timestamp of when the completion was created. */
  created?: number;
  model?: string;
  object?: string;
  usage?: OpenAIUsage;
}

export type OpenAIDeltaRole = typeof OpenAIDeltaRole[keyof typeof OpenAIDeltaRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIDeltaRole = {
  assistant: 'assistant',
} as const;

/**
 * @nullable
 */
export type OpenAIDeltaFunctionCall = { [key: string]: unknown } | null;

/**
 * @nullable
 */
export type OpenAIDeltaToolCalls = { [key: string]: unknown } | null;

export interface OpenAIDelta {
  /** @nullable */
  content?: string | null;
  role?: OpenAIDeltaRole;
  /** @nullable */
  function_call?: OpenAIDeltaFunctionCall;
  /** @nullable */
  tool_calls?: OpenAIDeltaToolCalls;
}

/**
 * @nullable
 */
export type OpenAIChatCompletionStreamChoiceLogprobs = { [key: string]: unknown } | null;

export interface OpenAIChatCompletionStreamChoice {
  delta?: OpenAIDelta;
  /** @nullable */
  finish_reason?: string | null;
  index?: number;
  /** @nullable */
  logprobs?: OpenAIChatCompletionStreamChoiceLogprobs;
}

export interface OpenAIChatCompletionStreamResponse {
  id?: string;
  choices?: OpenAIChatCompletionStreamChoice[];
  /** Unix timestamp of when the completion was created. */
  created?: number;
  model?: string;
  object?: string;
  system_fingerprint?: string;
  /** @nullable */
  usage?: OpenAIUsage;
}

export interface ErrorResponse {
  code?: number;
  message?: string;
}

export type SuccessSimpleResponse = {
  code?: number;
};

export type SuccessWithMessageResponse = {
  code?: number;
  data?: boolean;
  message?: string;
};

/**
 * Bad Request. The server cannot or will not process the request due to something that is perceived to be a client error.
 */
export type BadRequestResponse = ErrorResponse;

/**
 * Forbidden. The client does not have access rights to the content.
 */
export type ForbiddenResponse = ErrorResponse;

/**
 * Not Found. The server can not find the requested resource.
 */
export type NotFoundResponse = ErrorResponse;

/**
 * Conflict. The request conflicts with the current state of the server.
 */
export type ConflictResponse = ErrorResponse;

/**
 * Specifies the page on which the items will be displayed.
 */
export type PageQueryParameter = number;

/**
 * The number of items on each page.
 */
export type PageSizeQueryParameter = number;

export type OrderbyQueryParameter = typeof OrderbyQueryParameter[keyof typeof OrderbyQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderbyQueryParameter = {
  create_time: 'create_time',
  update_time: 'update_time',
} as const;

/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
export type DescQueryParameter = boolean;

/**
 * The name of the item to retrieve.
 */
export type NameQueryParameter = string;

/**
 * The ID of the item to retrieve.
 */
export type IdQueryParameter = string;

/**
 * The keywords used to match content.
 */
export type KeywordsQueryParameter = string;

/**
 * The optional user-defined ID.
 */
export type UserIdQueryParameter = string;

/**
 * Indicates whether to include the dsl field of the sessions in the response.
 */
export type DslQueryParameter = boolean;

export type ListDatasetsParams = {
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The number of items on each page.
 */
page_size?: PageSizeQueryParameter;
/**
 * The field by which datasets should be sorted.
 */
orderby?: OrderbyQueryParameter;
/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
desc?: DescQueryParameter;
/**
 * The name of the item to retrieve.
 */
name?: NameQueryParameter;
/**
 * The ID of the item to retrieve.
 */
id?: IdQueryParameter;
};

export type UploadDocumentsBody = {
  /** One or more documents to upload. */
  file?: Blob[];
};

export type ListDocumentsParams = {
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The number of items on each page.
 */
page_size?: PageSizeQueryParameter;
/**
 * The field by which documents should be sorted.
 */
orderby?: ListDocumentsOrderby;
/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
desc?: DescQueryParameter;
/**
 * The keywords used to match content.
 */
keywords?: KeywordsQueryParameter;
/**
 * The ID of the item to retrieve.
 */
id?: IdQueryParameter;
/**
 * The name of the item to retrieve.
 */
name?: NameQueryParameter;
};

export type ListDocumentsOrderby = typeof ListDocumentsOrderby[keyof typeof ListDocumentsOrderby];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListDocumentsOrderby = {
  create_time: 'create_time',
  update_time: 'update_time',
} as const;

export type ListChunksParams = {
/**
 * The keywords used to match content.
 */
keywords?: KeywordsQueryParameter;
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The maximum number of chunks on each page.
 */
page_size?: number;
/**
 * The ID of the chunk to retrieve.
 */
id?: string;
};

export type ListChatAssistantsParams = {
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The number of items on each page.
 */
page_size?: PageSizeQueryParameter;
/**
 * The field by which datasets should be sorted.
 */
orderby?: OrderbyQueryParameter;
/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
desc?: DescQueryParameter;
/**
 * The name of the item to retrieve.
 */
name?: NameQueryParameter;
/**
 * The ID of the item to retrieve.
 */
id?: IdQueryParameter;
};

export type ListChatSessionsParams = {
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The number of items on each page.
 */
page_size?: PageSizeQueryParameter;
/**
 * The field by which datasets should be sorted.
 */
orderby?: OrderbyQueryParameter;
/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
desc?: DescQueryParameter;
/**
 * The name of the item to retrieve.
 */
name?: NameQueryParameter;
/**
 * The ID of the item to retrieve.
 */
id?: IdQueryParameter;
/**
 * The optional user-defined ID.
 */
user_id?: UserIdQueryParameter;
};

export type ListAgentsParams = {
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The number of items on each page.
 */
page_size?: PageSizeQueryParameter;
/**
 * The field by which datasets should be sorted.
 */
orderby?: OrderbyQueryParameter;
/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
desc?: DescQueryParameter;
/**
 * The name of the item to retrieve.
 */
name?: NameQueryParameter;
/**
 * The ID of the item to retrieve.
 */
id?: IdQueryParameter;
};

export type CreateAgentSessionParams = {
/**
 * The optional user-defined ID.
 */
user_id?: UserIdQueryParameter;
};

/**
 * Dynamic parameters based on the agent's Begin component.
 */
export type CreateAgentSessionBodyOne = { [key: string]: unknown };

export type CreateAgentSessionBodyTwo = {
  /** A file to be used by the agent. The form key should match the parameter name in the Begin component. */
  file?: Blob;
  [key: string]: unknown;
 };

export type ListAgentSessionsParams = {
/**
 * Specifies the page on which the items will be displayed.
 */
page?: PageQueryParameter;
/**
 * The number of items on each page.
 */
page_size?: PageSizeQueryParameter;
/**
 * The field by which datasets should be sorted.
 */
orderby?: OrderbyQueryParameter;
/**
 * Indicates whether the retrieved items should be sorted in descending order.
 */
desc?: DescQueryParameter;
/**
 * The ID of the item to retrieve.
 */
id?: IdQueryParameter;
/**
 * The optional user-defined ID.
 */
user_id?: UserIdQueryParameter;
/**
 * Indicates whether to include the dsl field of the sessions in the response.
 */
dsl?: DslQueryParameter;
};

/**
 * Creates a new dataset.
 * @summary Create dataset
 */
export const createDataset = <TData = AxiosResponse<CreateDatasetResponse>>(
    createDatasetRequest: CreateDatasetRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/datasets`,
      createDatasetRequest,options
    );
  }

/**
 * Retrieves a paginated list of datasets, with options for filtering and sorting.
 * @summary List datasets
 */
export const listDatasets = <TData = AxiosResponse<ListDatasetsResponse>>(
    params?: ListDatasetsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletes one or more datasets by their IDs. If the list of IDs is null, all datasets are deleted.
 * @summary Delete datasets
 */
export const deleteDatasets = <TData = AxiosResponse<SuccessSimpleResponse>>(
    deleteDatasetsRequest: DeleteDatasetsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/datasets`,{data:
      deleteDatasetsRequest, ...options}
    );
  }

/**
 * Updates the configuration for a specified dataset.
 * @summary Update dataset
 */
export const updateDataset = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    updateDatasetRequest: UpdateDatasetRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/datasets/${datasetId}`,
      updateDatasetRequest,options
    );
  }

/**
 * Uploads one or more documents to a specified dataset.
 * @summary Upload documents
 */
export const uploadDocuments = <TData = AxiosResponse<UploadDocumentsResponse>>(
    datasetId: string,
    uploadDocumentsBody: UploadDocumentsBody, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
if(uploadDocumentsBody.file !== undefined) {
 uploadDocumentsBody.file.forEach(value => formData.append(`file`, value));
 }

    return axios.post(
      `/datasets/${datasetId}/documents`,
      formData,options
    );
  }

/**
 * Lists documents in a specified dataset.
 * @summary List documents
 */
export const listDocuments = <TData = AxiosResponse<ListDocumentsResponse>>(
    datasetId: string,
    params?: ListDocumentsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${datasetId}/documents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletes documents by ID from a specified dataset.
 * @summary Delete documents
 */
export const deleteDocuments = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    deleteDocumentsRequest: DeleteDocumentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/datasets/${datasetId}/documents`,{data:
      deleteDocumentsRequest, ...options}
    );
  }

/**
 * Downloads a document from a specified dataset.
 * @summary Download document
 */
export const downloadDocument = <TData = AxiosResponse<Blob>>(
    datasetId: string,
    documentId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${datasetId}/documents/${documentId}`,{
        responseType: 'blob',
    ...options,}
    );
  }

/**
 * Updates configurations for a specified document.
 * @summary Update document
 */
export const updateDocument = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    documentId: string,
    updateDocumentRequest: UpdateDocumentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/datasets/${datasetId}/documents/${documentId}`,
      updateDocumentRequest,options
    );
  }

/**
 * Starts the parsing process for specified documents in a dataset.
 * @summary Parse documents
 */
export const parseDocuments = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    manageParsingRequest: ManageParsingRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/datasets/${datasetId}/chunks`,
      manageParsingRequest,options
    );
  }

/**
 * Stops the parsing process for specified documents.
 * @summary Stop parsing documents
 */
export const stopParsingDocuments = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    manageParsingRequest: ManageParsingRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/datasets/${datasetId}/chunks`,{data:
      manageParsingRequest, ...options}
    );
  }

/**
 * Adds a chunk to a specified document in a specified dataset.
 * @summary Add chunk
 */
export const addChunk = <TData = AxiosResponse<AddChunkResponse>>(
    datasetId: string,
    documentId: string,
    addChunkRequest: AddChunkRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/datasets/${datasetId}/documents/${documentId}/chunks`,
      addChunkRequest,options
    );
  }

/**
 * Lists chunks in a specified document.
 * @summary List chunks
 */
export const listChunks = <TData = AxiosResponse<ListChunksResponse>>(
    datasetId: string,
    documentId: string,
    params?: ListChunksParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${datasetId}/documents/${documentId}/chunks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletes chunks by ID.
 * @summary Delete chunks
 */
export const deleteChunks = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    documentId: string,
    deleteChunksRequest: DeleteChunksRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/datasets/${datasetId}/documents/${documentId}/chunks`,{data:
      deleteChunksRequest, ...options}
    );
  }

/**
 * Updates content or configurations for a specified chunk.
 * @summary Update chunk
 */
export const updateChunk = <TData = AxiosResponse<SuccessSimpleResponse>>(
    datasetId: string,
    documentId: string,
    chunkId: string,
    updateChunkRequest: UpdateChunkRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/datasets/${datasetId}/documents/${documentId}/chunks/${chunkId}`,
      updateChunkRequest,options
    );
  }

/**
 * Retrieves chunks from specified datasets.
 * @summary Retrieve chunks
 */
export const retrieveChunks = <TData = AxiosResponse<RetrieveChunksResponse>>(
    retrieveChunksRequest: RetrieveChunksRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/retrieval`,
      retrieveChunksRequest,options
    );
  }

/**
 * Creates a chat assistant.
 * @summary Create chat assistant
 */
export const createChatAssistant = <TData = AxiosResponse<ChatAssistantResponse>>(
    createChatAssistantRequest: CreateChatAssistantRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/chats`,
      createChatAssistantRequest,options
    );
  }

/**
 * Lists chat assistants.
 * @summary List chat assistants
 */
export const listChatAssistants = <TData = AxiosResponse<ListChatAssistantsResponse>>(
    params?: ListChatAssistantsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/chats`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletes chat assistants by ID.
 * @summary Delete chat assistants
 */
export const deleteChatAssistants = <TData = AxiosResponse<SuccessSimpleResponse>>(
    deleteChatAssistantsRequest: DeleteChatAssistantsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/chats`,{data:
      deleteChatAssistantsRequest, ...options}
    );
  }

/**
 * Updates configurations for a specified chat assistant.
 * @summary Update chat assistant
 */
export const updateChatAssistant = <TData = AxiosResponse<SuccessSimpleResponse>>(
    chatId: string,
    updateChatAssistantRequest: UpdateChatAssistantRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/chats/${chatId}`,
      updateChatAssistantRequest,options
    );
  }

/**
 * Creates a session with a chat assistant.
 * @summary Create chat session
 */
export const createChatSession = <TData = AxiosResponse<SessionResponse>>(
    chatId: string,
    createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/chats/${chatId}/sessions`,
      createSessionRequest,options
    );
  }

/**
 * Lists sessions associated with a specified chat assistant.
 * @summary List chat sessions
 */
export const listChatSessions = <TData = AxiosResponse<ListSessionsResponse>>(
    chatId: string,
    params?: ListChatSessionsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/chats/${chatId}/sessions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletes sessions of a chat assistant by ID.
 * @summary Delete chat sessions
 */
export const deleteChatSessions = <TData = AxiosResponse<SuccessSimpleResponse>>(
    chatId: string,
    deleteSessionsRequest: DeleteSessionsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/chats/${chatId}/sessions`,{data:
      deleteSessionsRequest, ...options}
    );
  }

/**
 * Updates a session of a specified chat assistant.
 * @summary Update chat session
 */
export const updateChatSession = <TData = AxiosResponse<SuccessSimpleResponse>>(
    chatId: string,
    sessionId: string,
    updateSessionRequest: UpdateSessionRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/chats/${chatId}/sessions/${sessionId}`,
      updateSessionRequest,options
    );
  }

/**
 * Asks a specified chat assistant a question to start an AI-powered conversation.
This endpoint supports streaming responses using Server-Sent Events (SSE).
When `stream` is true, the response will be of `text/event-stream` type.
The stream is a series of JSON objects prefixed with `data:`.
The final message in the stream is `data: {"code": 0, "data": true}`.
 * @summary Converse with chat assistant
 */
export const converseWithChatAssistant = <TData = AxiosResponse<ConversationResponse>>(
    chatId: string,
    conversationRequest: ConversationRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/chats/${chatId}/completions`,
      conversationRequest,options
    );
  }

/**
 * Lists agents.
 * @summary List agents
 */
export const listAgents = <TData = AxiosResponse<ListAgentsResponse>>(
    params?: ListAgentsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/agents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Create an agent.
 * @summary Create agent
 */
export const createAgent = <TData = AxiosResponse<SuccessWithMessageResponse>>(
    createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/agents`,
      createAgentRequest,options
    );
  }

/**
 * Update an agent by id.
 * @summary Update agent
 */
export const updateAgent = <TData = AxiosResponse<SuccessWithMessageResponse>>(
    agentId: string,
    updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/agents/${agentId}`,
      updateAgentRequest,options
    );
  }

/**
 * Delete an agent by id.
 * @summary Delete agent
 */
export const deleteAgent = <TData = AxiosResponse<SuccessWithMessageResponse>>(
    agentId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/agents/${agentId}`,options
    );
  }

/**
 * Creates a session with an agent.
The request body can be `application/json` or `multipart/form-data` if files are needed for the `Begin` component of the agent.
The parameters in the body are dynamic and depend on the agent's `Begin` component configuration.
 * @summary Create agent session
 */
export const createAgentSession = <TData = AxiosResponse<CreateAgentSessionResponse>>(
    agentId: string,
    createAgentSessionBody: CreateAgentSessionBodyOne | CreateAgentSessionBodyTwo,
    params?: CreateAgentSessionParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/agents/${agentId}/sessions`,
      createAgentSessionBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Lists sessions associated with a specified agent.
 * @summary List agent sessions
 */
export const listAgentSessions = <TData = AxiosResponse<ListAgentSessionsResponse>>(
    agentId: string,
    params?: ListAgentSessionsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/agents/${agentId}/sessions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletes sessions of an agent by ID.
 * @summary Delete agent sessions
 */
export const deleteAgentSessions = <TData = AxiosResponse<SuccessSimpleResponse>>(
    agentId: string,
    deleteSessionsRequest: DeleteSessionsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/agents/${agentId}/sessions`,{data:
      deleteSessionsRequest, ...options}
    );
  }

/**
 * Asks a specified agent a question to start an AI-powered conversation.
This endpoint supports streaming responses and dynamic parameters based on the agent's `Begin` component.
When `stream` is true, the response will be of `text/event-stream` type.
The stream is a series of JSON objects prefixed with `data:`.
The final message in the stream is `data: {"code": 0, "data": true}`.
 * @summary Converse with agent
 */
export const converseWithAgent = <TData = AxiosResponse<AgentConversationResponse>>(
    agentId: string,
    agentConversationRequest: AgentConversationRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/agents/${agentId}/completions`,
      agentConversationRequest,options
    );
  }

/**
 * Generates five to ten alternative question strings from the user's original query.
**Note:** This endpoint uses a different base path (`/v1/` instead of `/api/v1/`) and requires a short-lived Bearer Login Token.
 * @summary Generate related questions
 */
export const generateRelatedQuestions = <TData = AxiosResponse<RelatedQuestionsResponse>>(
    relatedQuestionsRequest: RelatedQuestionsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/sessions/related_questions`,
      relatedQuestionsRequest,options
    );
  }

/**
 * Creates a model response for a given chat conversation with a chat assistant, using an OpenAI-compatible format.
 * @summary Create chat completion (Chat Assistant)
 */
export const createOpenAIChatCompletion = <TData = AxiosResponse<OpenAIChatCompletionResponse | OpenAIChatCompletionStreamResponse>>(
    chatId: string,
    openAIChatCompletionRequest: OpenAIChatCompletionRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/chats_openai/${chatId}/chat/completions`,
      openAIChatCompletionRequest,options
    );
  }

/**
 * Creates a model response for a given chat conversation with an agent, using an OpenAI-compatible format.
 * @summary Create chat completion (Agent)
 */
export const createOpenAIAgentCompletion = <TData = AxiosResponse<OpenAIChatCompletionResponse | OpenAIChatCompletionStreamResponse>>(
    agentId: string,
    openAIChatCompletionRequest: OpenAIChatCompletionRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/agents_openai/${agentId}/chat/completions`,
      openAIChatCompletionRequest,options
    );
  }

export type CreateDatasetResult = AxiosResponse<CreateDatasetResponse>
export type ListDatasetsResult = AxiosResponse<ListDatasetsResponse>
export type DeleteDatasetsResult = AxiosResponse<SuccessSimpleResponse>
export type UpdateDatasetResult = AxiosResponse<SuccessSimpleResponse>
export type UploadDocumentsResult = AxiosResponse<UploadDocumentsResponse>
export type ListDocumentsResult = AxiosResponse<ListDocumentsResponse>
export type DeleteDocumentsResult = AxiosResponse<SuccessSimpleResponse>
export type DownloadDocumentResult = AxiosResponse<Blob>
export type UpdateDocumentResult = AxiosResponse<SuccessSimpleResponse>
export type ParseDocumentsResult = AxiosResponse<SuccessSimpleResponse>
export type StopParsingDocumentsResult = AxiosResponse<SuccessSimpleResponse>
export type AddChunkResult = AxiosResponse<AddChunkResponse>
export type ListChunksResult = AxiosResponse<ListChunksResponse>
export type DeleteChunksResult = AxiosResponse<SuccessSimpleResponse>
export type UpdateChunkResult = AxiosResponse<SuccessSimpleResponse>
export type RetrieveChunksResult = AxiosResponse<RetrieveChunksResponse>
export type CreateChatAssistantResult = AxiosResponse<ChatAssistantResponse>
export type ListChatAssistantsResult = AxiosResponse<ListChatAssistantsResponse>
export type DeleteChatAssistantsResult = AxiosResponse<SuccessSimpleResponse>
export type UpdateChatAssistantResult = AxiosResponse<SuccessSimpleResponse>
export type CreateChatSessionResult = AxiosResponse<SessionResponse>
export type ListChatSessionsResult = AxiosResponse<ListSessionsResponse>
export type DeleteChatSessionsResult = AxiosResponse<SuccessSimpleResponse>
export type UpdateChatSessionResult = AxiosResponse<SuccessSimpleResponse>
export type ConverseWithChatAssistantResult = AxiosResponse<ConversationResponse>
export type ListAgentsResult = AxiosResponse<ListAgentsResponse>
export type CreateAgentResult = AxiosResponse<SuccessWithMessageResponse>
export type UpdateAgentResult = AxiosResponse<SuccessWithMessageResponse>
export type DeleteAgentResult = AxiosResponse<SuccessWithMessageResponse>
export type CreateAgentSessionResult = AxiosResponse<CreateAgentSessionResponse>
export type ListAgentSessionsResult = AxiosResponse<ListAgentSessionsResponse>
export type DeleteAgentSessionsResult = AxiosResponse<SuccessSimpleResponse>
export type ConverseWithAgentResult = AxiosResponse<AgentConversationResponse>
export type GenerateRelatedQuestionsResult = AxiosResponse<RelatedQuestionsResponse>
export type CreateOpenAIChatCompletionResult = AxiosResponse<OpenAIChatCompletionResponse | OpenAIChatCompletionStreamResponse>
export type CreateOpenAIAgentCompletionResult = AxiosResponse<OpenAIChatCompletionResponse | OpenAIChatCompletionStreamResponse>
